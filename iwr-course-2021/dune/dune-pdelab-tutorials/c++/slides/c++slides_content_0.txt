[1.0]

[2.0][2.1]
[2.2]
[2.3]

[2.4]

[2.5]
[2.6]

[2.7]
  [2.8]
  使用DUNE需要一些高级的C++特性，或者说使其使用更加容易。
  它的使用更容易。其中一些是在最近的
  C++语言标准C++11、C++14和C++17。我们将具体看一下。
  [2.9]
  [2.10] 在基于Linux的系统上编译程序
  [2.11] 面向对象的编程
  [2.12] 命名空间
  [2.13] 自动类型推理
  [2.14] 模板
  [2.15] C++标准库的容器
  [2.16] 基于范围的for循环
  [2.17] Lambda函数
  [2.18]
[2.19]

[2.20]
[2.21]
  [2.22]
  在基于Linux的系统上，（GNU-）C++编译器被称为[2.23]，你可以像这样运行它。
  [1.1]
用[2.24]（在Windows系统上，选项可能不同），例如。
  [1.2]

如果你的程序被成功编译（没有错误信息），你就用以下方式运行它。
  [1.3]
并得到例如以下的输出
  [1.4]
[2.25]

[2.26]
  [2.27]
  对于更复杂的软件项目，通常会提供所谓的makefile。makefile确保在执行命令[2.28]时，项目的所有相关源文件都被编译。
  [1.5]
  如果你只改变了一些源文件后构建项目，只有这些文件被重新编译，这可以大大加快进程。
  
  对于DUNE来说，makefiles是由一个叫做[2.29]的工具生成的。
[2.30]

[2.31]

[2.32]
[2.33]
面向对象编程的基本思想是定义具有一定功能的组件。这些组件结合了提供和控制该功能所需的方法以及相关的数据。不同的组件通过接口连接。同样的接口被用于提供相同的一般功能的专门组件。

这种方法有几个优点。
[2.34]
[2.35] 不同的组件可以单独开发。
[2.36] 如果一个组件的改进版本可用，它们可以在不对程序代码进行重大修改的情况下被使用。
[2.37] 可以很容易地使用同一个组件的几个实现。
[2.38]

这也被用于现实世界，例如，汽车的轮胎、CPU的插座、电脑的USB接口、打印机、手机[2.39] 。
[2.40]

[2.41]
[2.42]
在C++中，这个想法是通过类和对象实现的。类描述了一个组件的功能和结构。这个蓝图的实现被称为对象。

让我们用一个二维矢量作为例子。
[2.43]
[2.44] 矢量由两个组件组成。
[2.45] 必要的操作是长度（规范），两个向量之和，向量与标量的乘法，[2.46] 。
[2.47] 初始化。创建一个具有定义状态的向量。
[2.48][2.49] [2.50]
[2.51] 和 [2.52] 是不同的向量，但它们有相同的结构。
[2.54]
[2.55]{[2.56] C++语言概念}。
[2.57] 描述了类似对象的语义（向量、函数空间、线性求解器，[2.58]）。
[2.59]
[2.60]

[2.61]
  [2.62]
  [1.6]
[2.63]

[2.64]
  [2.65]
 类定义了一个新的数据类型。
[2.66]
  [2.67] [2.68], [2.69]的变量）。)
    [1.7]
  [2.70] 一个[2.71]的成员变量和函数是通过变量名称后的点和变量/函数的名称来访问。
    [1.8]
  [2.72] [2.73] 的对象可以像普通变量一样使用。
    [1.9]
  [2.74]
[2.75]

[2.76]
  [2.77]
  [2.78]
  [2.79] 一个[2.80]的数据成员和方法）。)
  [2.81] 如果你试图从类外访问一个[2.82]成员，你会得到一个编译器错误。
    [1.10]
  [2.83] 建议将[2.84]的数据成员变成私有。这被称为[2.85]，便于以后改变数据的存储方式，这通常可以大大改善性能。
  [2.86]
[2.87]

[2.88]

[2.89]
  [2.90]
  [2.91]
  [2.92] 让我们假设你想用头文件[2.93]来使用两个现有的库。
  [2.94] 都定义了一个函数[2.95]。
  [2.96] 编译器无法区分它们!
  [2.97] 如何才能在不发生名称冲突的情况下使用这两个库？
  [2.98]
  
[2.99]

[2.100]
  [2.101]
  C++使用命名空间，可以轻松解决这个问题。
[1.11]
每个[2.102]包含其数据成员和函数。
[2.103]

[2.104]
  [2.105]{Builtin名称空间[2.106]}。
  [2.107]
  [2.108] C++还包含一个有用的函数和类库，即所谓的标准库。
  [2.109] 初学者经常写 
  [1.12]
在他们程序的顶部，将标准库的所有函数导入全局命名空间。
  [2.110] 你应该[2.111]这样做，因为这可能导致名称冲突，并降低进一步开发的灵活性
  [2.112]
  
[2.113]

[2.114]
  [2.115][2.116]{Builtin Namespace [2.117]}。
只要在函数和类型前面写上命名空间[2.118]即可。
  [1.13]
  如果你使用现代编辑器的自动补全功能，这并没有太多的打字开销，而且比以后重写代码的工作量要小得多。
[2.119]

[2.120]

[2.121]
[2.122]

从C++11开始，如果能从变量的初始化中推断出变量所需的类型，就可以自动检测。这可以用关键字[2.123]来表示。

[2.124]

[2.125]

[2.126]
[2.127]{[2.128]: 优势}。

[2.129]
[2.130] 使用[2.131]）有很多优点（以牺牲一点细节控制为代价）。
[2.132]
[2.133] 如果你用[2.134]创建一个变量，它将总是被初始化为一个已定义的值，这就避免了一大类非常微妙的错误。
[2.135] 如果你写了[2.136]，编译器可以选择正确的类型，减少错误的风险。
[2.137] 当使用像DUNE这样的高级库时，变量的类型会变得非常复杂，使人很难读到写明这些类型的代码。
[2.138]
[2.139] 只有从C++14开始，才有可能在函数定义和声明中使用[2.140]。
[2.141]

[2.142]

[2.143]
[2.144]{[2.145]和字面意思}。

对于用[2.146]进行类型推导，适用于C++字面的通常规则。

[2.147]

[2.148]

[2.149]
  [2.150]
  [2.151]
  [2.152] 在C++中，如果变量被传递给一个函数，默认情况下会生成一个变量的副本。
  [2.153] 引用是一种选择，它只为相同的数据生成一个新的名字。
  [2.154] 引用是通过添加一个[2.155]来生成的。
  [2.156] 你只能生成对现有变量的引用，而不是对字面意义的引用!
  [2.157]
  
[2.158]

[2.159]
  [2.160][2.161]{[2.162] 和引用}。
  [2.163]
  [2.164] 如果你想让一个变量成为自动类型推理的引用，请写[2.165]。
  [2.166]

  [1.14]
[2.167]


[2.168]

[2.169]

[2.170]
[2.171]


[2.172][2.173]
[2.174] 通常不同的数据类型需要相同的算法。
[2.175] 如果没有通用编程，就必须为所有的数据类型编写相同的函数，这很乏味，而且容易出错，例如
[2.176]
[2.177]
[2.178]{2}
    [1.15]

    [1.16]
[2.179]
[2.180]-7mm
[2.181]
[2.182] 通用编程允许一次性编写算法，并以数据类型为参数来确定算法。
数据类型。
[2.183]

[2.184]

[2.185]

[2.186]
[2.187]
[2.188][2.189]
[2.190] 一个函数模板以关键字[2.191]|template|和一个或多个模板参数的列表开始。
在角括号中，由逗号分隔。
[1.17]
[2.192] 如果使用了模板，编译器可以根据函数参数从函数模板中自动生成函数（与重载一样，返回类型不相关）。
 [2.193] 也可以明确指定模板参数。
 [1.18]
 [2.194] 参数类型必须符合声明的内容
[2.195]
[2.196]

[2.197]

[2.198]
[2.199]
[1.19]
[2.200]

[2.201]

[2.202]
[2.203]
[1.20]
[2.204]

[2.205]

[2.206]
[2.207]
C++标准库已经提供了一些有用的模板函数。
[2.208][2.209]
[2.210] [2.211] [2.212]
  a和b的最小值[2.213]。
  [1.21]
[2.214] [2.215] [2.216]
  A和B的最大值[2.217]
  [1.22]
[2.218] [2.219] [2.220]
  交换a和b[2.221] 。
  [1.23]
[2.222]
[2.223]


[2.224]

[2.225]
[2.226]
[1.24]
[2.227][2.228]
[2.229] 模板参数可以在类的声明中使用。
[2.230] 不仅是类型，还有整数值都可以作为模板参数使用。在模板实例化中使用的值必须是编译时的常量。
[2.231] 如果在类定义中使用模板，最后的模板参数可以有默认值。
[2.232] 类的名称是指类的名称加上模板参数。
[2.233]

[2.234]

[2.235]

[2.236]
[2.237]
[1.25]
[2.238][2.239]
[2.240] 如果一个类是从一个模板类派生出来的，那么模板参数必须作为基类名称的一部分给出。
作为基类名称的一部分。
[2.241] 基类构造函数的调用以及基类成员和方法的前缀也是如此。
基类成员和方法的前缀。
[2.242]

[2.243]


[2.244]

[2.245]
[2.246]
[1.26]
[2.247]
[2.248] 模板基类的成员往往不能自动正确解决
[2.249] 为了避免问题，（作为一条经验法则）总是在基类成员（方法和变量）前面加上
基类成员（方法和变量）前加上[2.250] 。
[2.251]

[2.252]


[2.253]

[2.254]
[2.255]
[2.256]
[2.257] 如果不使用模板，因此不进行实例化，模板代码只被编译器检查是否有粗略的语法错误（如~缺少分号）。
编译器检查粗略的语法错误（例如~遗漏的分号）。
[2.258] 测试，如果所有的函数调用都是有效的，是在模板实例化时进行的。
像缺失函数这样的错误只有在那时才会被发现。错误信息可能相当奇怪。
[2.259] 由于代码只在模板实例化时创建，编译器必须在这个时候知道整个函数定义，不仅是它的定义。
整个函数的定义，而不仅仅是它的声明。
[2.260] 因此，对模板来说，通常的头文件和源文件的细分是不可能的。
[2.261]
[2.262]

[2.263]

[2.264]
[2.265]
[2.266]
[2.267] 为了节省计算时间和内存，只生成真正被调用的类函数。
[2.268] 因此
类模板也可以被实例化为不支持所有必要操作的类型，只要在需要它们的地方有方法。
只要需要它们的方法不被调用。
[2.269] 如果模板类有很长的参数列表，类型定义是有帮助的。
[1.27]

[2.270]
[2.271]

[2.272]
[2.273]
[1.28]


[2.274]
[2.275] 为长类型名称定义缩写的另一种方法被称为 "模板别名"。
[2.276] 同时，部分模板别名也可以固定一些模板参数。
[2.277]

[2.278]


[2.279]

[2.280]
[2.281]{关键词[2.282]}。
[1.29]
[2.283][2.284]
[2.285] 在C++中，默认情况下，类模板的成员不被认为是一种类型，而是
一个（静态）变量。
[2.286] 需要使用[2.287]关键字来表示类的成员(静态)。
表示一个类的成员（作为模板参数给出或依赖于模板参数）是一个类型。
参数）是一个类型。
[2.288] 它只在模板内需要/允许使用。
[2.289] 它不用于基类规范列表或成员初始化器列表中
在构造函数定义中。
[2.290]

[2.291]


[2.292]

[2.293]
[2.294]{关键词[2.295]}。
[1.30]
[2.296][2.297]
[2.298] C++默认假设对象后面的每个[2.299]字符都是比较的开始。
[2.300] 在这样一个方法名称前面的关键字[2.301]表示
一个明确的模板参数。
[2.302]

[2.303]


[2.304]

[2.305]

[2.306]

[2.307]
[2.308]
标准库（有时称为STL，代表标准模板库）是
[2.309][2.310]
[2.311] 一个有用的模板函数和类的集合。
[2.312] 可用于所有现代C++编译器。
[2.313] 为提高效率而优化的。
[2.314] 比使用普通的C语言库和数据结构要安全得多。
[2.315]
[2.316]

[2.317]

[2.318]
[2.319]

[2.320]
[2.321] 数据表示法对于算法的效率往往至关重要
[2.322] STL定义了容器和使用它们的算法。
[2.323] 容器被用来管理元素的集合。
[2.324] 迭代器提供了一个通用的接口来遍历容器中的元素。
[2.325] 有各种各样的容器为不同的目的进行优化。
[2.326]
[2.327]

图自：[2.328]
[2.329]
[2.330]

[2.331]

[2.332]


[2.333]
  [2.334]
  STL包含一个叫做[2.335]的动态数组，它比其普通的
  C的对应物要好得多。
  [2.336]
  [2.337] 当你不再需要它时，它会自动释放内存，避免了内存泄漏。
  [2.338] 它知道自己的大小，所以你不必记住它。
  [2.339] 如果你需要一个更大的向量，它可以自动调整自己的大小。
  [2.340] 它是一个模板。你指定要存储在它里面的对象的类型。
  [2.341] 它很快速。
  [2.342]
[2.343]


[2.344]
[2.345]
[2.346]
[2.347]
[2.348]
[2.349]
[2.350]
[2.351]
[2.352]
[2.353]
[2.354]
[2.355]
[2.356]
[2.357]
[2.358]
[2.359]
[2.360]

[2.361]

[2.362]
[2.363]
下面的例子说明如何使用[2.364]。
[1.31]
[2.365]

[2.366]
[2.367]
[2.368]
[2.369] 容器概念的一个重要部分是对存储在容器中的所有元素进行迭代的通用方案，它与使用所谓迭代器的容器类型无关。
[2.370] 迭代器的使用语法来自于普通C语言中指针的使用。
[2.371] 每个容器都有一个方法[2.372]，它返回一个指向该容器第一个成员的迭代器。
[2.373] 迭代器的数据类型是[2.374]（但如果你使用auto，你就不需要知道这个）。
[2.375] 如果你调用迭代器的增量运算符[2.376]，它将在之后指向下一个元素。
[2.377] 你可以通过比较迭代器和[2.378]来检查你是否到达了容器的末端。
[2.379]
[2.380]

[2.381]
[2.382]
[2.383]
[2.384] 要访问迭代器所指向的元素，你必须解除对它的引用，例如 [2.385] 。
[2.386] 如果容器的元素是一个类的对象，你也可以使用操作符[2.387]来访问该类的数据成员或函数。
[2.388]
[2.389]
[2.390]

[2.391]

[2.392]
  [2.393][2.394]{基于范围的[2.395] 循环}。
  使用基于范围的[2.396]循环，同样的操作（在整个容器上迭代）可以写得更简单。
  [1.32]
  [2.397]
  [2.398] 对C数组和所有STL容器都有效。
  [2.399] 对于使用DUNE也很重要!
  [2.400] 小心：你在基于范围的[2.401]-循环中得到的不是一个迭代器。你不需要解除引用它。你可以直接使用它来访问内容。
  [2.402]
[2.403]

[2.404]
  [2.405][2.406]{基于范围的 [2.407] 循环}。

  你可以得到当前访问的元素的副本或引用（如果你写了[2.408]）。

  [1.33]

[2.409]

[2.410]

[2.411]
[2.412]
[2.413]
[2.414] [2.415] 决定一个表达式的结果类型（不是结果值）。它可以用来制作匹配的变量。
[1.34]
[2.416] 与模板别名一起，它可以 
用来存储类型。
[2.417] 
[2.418] 与[2.419]的区别。不创建相同类型的变量，而是存储类型，也保留了引用。
[2.420] 如果你想把函数调用的结果存储在一个容器中，这很好。
[2.421]
[1.35]

[2.422]

[2.423]
[2.424]
[2.425]
[2.426] 在C++11中，[2.427]不能直接用于函数的定义或声明。只有从C++14开始才可以这样做。
[2.428] 函数的返回类型可以根据函数参数的类型来确定[2.429] 。
[2.430] [2.431] 确定一个给定操作的类型。
[2.432] 在最简单的版本中，[2.433]是一个给定操作。
[2.434]
[1.36]

[2.435]


[2.436]

[2.437]
  [2.438]
  [2.439]
  [2.440] C++11引入了一种简化的可能性来创建（主要是临时的）函数，即所谓的lambda表达式或lambdas。
  [2.441] 示例。
[1.37]
[2.442] 对于单个表达式，还有一个更短的版本（返回类型是自动计算的）。
[1.38]
[2.443] Lambdas可以像变量一样被存储，lambda函数的类型是由实现定义的。因此[2.444] 必须使用变量。
  [2.445]
[2.446]

[2.447]
  [2.448]
[2.449]
[2.450]
  [2.451]
  [2.452] Lambdas没有一个函数名。
  [2.453] 它们以一个捕获列表开始，确定周围范围的哪些变量在lambda中可用。
  [2.454] 接下来是一个普通的参数列表和一个返回（类似于[2.455]的规定），最后是函数的代码块。
  [2.456] 两种类型的捕获：通过值（创建一个副本）或通过引用（指向原始变量）。
  [2.457] 使用方法。列出变量名称，为引用添加安培号（[2.458]）。
  [2.459] 快捷方式。[2.460] 通过引用捕获所有变量
  [2.461] 从C++17开始，也可以将一个变量作为常量引用来捕获。[2.462]
  [2.463] [2.464] 当使用通过引用捕获时，请确保在调用lambda函数时原始变量仍然存在!
  [2.465]
[2.466]

[2.467]
[2.468]
[1.39]

[2.469]

[2.470] [2.471]{积累使用
    [2.472]：兰姆达函数}。

兰姆达函数对模板算法非常有用，例如，由标准模板库定义的算法。[2.473]算法将一个函数对象应用于容器中的每个元素。

[2.474]

  [1.40]
[2.475]



[2.476]

[2.477] [2.478]

[1.41]
[2.479]

[1.42]